Linux 从入门到精通（第二版 刘忆智著）

第1篇 基础篇
	第1章 Linux概述
	第2章 Linux安装
	第3章 Linux基本配置
	第4章 桌面环境

第1章 Linux概述
	略
第2章 Linux安装
	主要讲Ubuntu系统的安装
	关于硬盘分区
		硬盘一般分为IDE硬盘、SCSI硬盘和SATA硬盘。在Linux中，IDE接口的设备被称为hd,SCSI和SATA接口的设备则被称
		为sd(本书中如果不作特殊说明，默认将使用SCSI或SATA接口的硬盘)。第1块硬盘被称作sda,第2块被称作sdb,以此
		类推。Linux规定，一块硬盘上只能存在4个主分区，分别被命名为sda1、sda2、sda3和sda4。逻辑分区则从5开始标
		识，每多-一个逻辑分区，就在末尾的分区号上加1。逻辑分区没有数量限制。一般来说，每个系统都需要一个主分
		区来引导。这个分区中存放着引导整个系统所必需的程序和参数。在Windows环境中常说的C盘就是一个主分区，它
		是硬盘的第-一个分区，在Linux下被称为sdal。其后的D、E、F等属于逻辑分区，对应于Linux下的sda5、sda6、
		sd.....。操作系统主体可以安装在主分区，也可以安装在逻辑分区，但引导程序必须安装在主分区内。

		Grub对磁盘分区的表示方式和Linux有所不同。Grub 并不区分IDE、SCSI 抑或是SATA硬盘，所有的硬盘都被表示为
		“(hd#) ”的形式，其中“#”是从0开始编号的。例如，(hd0) 表示第1块硬盘，(hd1) 表示第2块硬盘....依此类推。
		对于任意一块硬盘(hd#)，(hd#,0) 、(hd#,1 )、(hd#,2) 、( hd#,3)依次表示它的4个主分区，而随后的(hd#,4) 
		....则是逻辑分区。例如图2.24中的(hd0,1)表示第1块硬盘的第2个主分区。

	主要搞懂，装Linux时各个分区的作用，如交换分区，主分区等

第3章 Linux基本配置
	root用户介绍
		su、sudo、exit命令用法
	软件更新
		设置速度最快的安装源，执行sudo apt-get update 更新软件包
	硬件驱动
		略
	设置自动更新
		略
	配置GRUB
		配置文件
			Grub启动时通常从boot/grub/grub.cfg读取引导配置，并且严格地依此行事。这段内容取自Grub配置文件给出的示例。
			
			# DO NOT EDIT THIS FILE ;
			# It is automatically generated by grub-mkconfig  using templates
			
			其大意为:请不要编辑此文件，该文件通过/etc/grub.d作为模版，通过/etc/default/grub作为配置，被grub-mkconfig
			命令自动生成。因此，我们打开此处指定的配置文件/etc/default/grub，查看并修改我们需要的功能参数。在终端执行
			下列命令。
			
			$ sudo gedit /etc/default/grub
			
			编辑其中需要修改的参数: GRUB_ DEFAULT 为引导项列表的默认选择项序号(从0数起) ; GRUB_ _TIMEOUT为引导项列表
			自动选择超时时间。同时我们也看到文件开头提到，修改grub 配置文件后须执行命令update -grub以更新grub.cfg文件。
			
			编辑完成并保存后回到终端,执行命令sudo update-grub,其将自动依照刚才编辑的配置文件(/etc/default/grub) 生成为
			引导程序准备的配置文件(/boot/grub/grub.cfg)。连续输出了各个引导项之后，输出done即已完成生成过程

			同时，引导项列表文件/boot/grub/grub.cfg 文件也已经被更新。
			
			引导Windows的配置则有些不同，下面这段内容同样是取自Grub配置文件的示例。
			title			Windows 95/98/NT/2000
			root			(hd0, 0)
			makeactive
			chainloader		+1

			关键字makeactive将root指定的分区设置为活动分区;关键字chainloader从指定位置加载Windows引导程序。如果安装双系统
			的话，建议先安装Windows,后安装Linux。然而随着Ubuntu内核的不断升级，grub修改开机启动菜单，会自动把最新的Ubuntu
			放在第一位，把Windows放在最后一个。我们经常希望把Windows调整到靠前的位置，可能还会修改默认的启动项和等待时间
			等。解决方案如下:
			(1)找到grub配置，打开配置文档，在终端里输入命令:
				$ sudo gedit /boot/grub/ grub.cfg
			(2)修改grub配置。
				set default="0": 表示默认的启动项，"0"表示第一个，依次类推。
				set timeout=10:表示默认等待时间，单位是秒。
				如果timeout被设置为0，那么用户就没有任何选择余地，Grub自动依照第1个title的指示引导系统。
			(3)找到windows的启动项，复制到所有Ubuntu启动项之前，例如:
				### BEGIN /etc/grub.d/30_ os-prober ###
				menuentry "Windows 7 (loader) (on /dev/sda1)" --class windows -class os {
				insmod part msdos
				insmod ntfs
				set root='(/dev/sda,msdos1)'
				search --no-floppy --fs-uuid --set=root A046A21446A1EAEC
				chainloader +1
				### END /etc/grub.d/30_ os-prober ###
			(4)保存并退出。

	使用GRUB命令行
		在GRUB启动画面出现时按下C键可以进入GRUB命令行模式，这时可以通过指令引导系统。
		感兴趣，到www.gnu.org/software/grub/manual/上下载官方手册

第4章 桌面环境
	图像环境
		在内核眼里，图形环境只是一个普通的应用程序，和其他服务器程序(如Apache、NFS等)没有什么不同。
	X窗口系统的基本组成
		X系统基于-种独特的服务器/客户机架构。
		X服务器
			X服务器用于实际控制输入设备(例如鼠标和键盘)和位图式输出设备(例如显示器)。准确地说，X服务器定义了给X客户机使用
			这些设备的抽象接口。
			这种设计的意义在于，X服务器能够做到最大程度上的与平台无关。用户可以自由选择窗口管理器和widget库来定制自己的桌
			面，而不需要改变窗口系统的底层配置。
		X客户端程序
			需要向X服务器请求服务的程序就是X客户端程序。具体来说，OpenOffice、 gedit这些应用程序都是X客户端程序，
			它们运行时需要把自己的“长相”描述给X服务器，然后由X服务器负责在显示器上绘制这些应用程序的界面。
		窗口管理器( Window Manager )
			窗口管理器负责控制应用程序窗口的各种行为，例如移动、缩放、最大化和最小化窗
			口，在多个窗口间切换等。从本质上来说，窗口管理器是一种特殊的X客户端程序，因为
			这些功能也都是通过向X服务器发送指令实现的。WindowMaker、FVWM、IceWM、Sawfish
			等是目前比较常见的窗口管理器。
		显示管理器(Display Manager )
			显示管理器提供了一个登录界面，其任务就是验证用户的身份，让用户登录到系统。
			可以说，图形界面的一切(除了它自己)都是由这个显示管理器启动的，包括X服务器。
			用户也可以选择关闭显示管理器，这样就必须通过命令行运行startx命令(或者使用.login
			脚本)来启动X服务器。
		widget库
			widget库定义了一套图形用户界面的编程接口。应用程序开发人员通过调用widget库
			来实现具体的用户界面，如按钮、菜单、滚动条、文本框等。程序员不需要理解X服务器
			的语言，widget库会把“画一个按钮”这句话翻译成X服务器能够理解的表述方式。
		桌面环境
			以KDE和Gnome为代表的Linux桌面环境是把各种与X有关的东西(除了X服务器)整合在一起的“大杂烩”。
	X系统的启动过程
		X系统的启动过程基本是由显示管理器(Display Manager)完成的。显示管理器启动后依次完成下面这些工作。
		(1)启动X服务器。
		(2)提供一个界面友好的屏幕，等待验证用户的身份。
		(3)执行用户的引导脚本，这个脚本用于建立用户的桌面环境。
		
		简单提一下“引导脚本”尽管到现在为止还没有正式接触“ 脚本”这个概念。桌面环境的引导脚本是一段用Linux命
		令组成的脚本程序，叫做Xsession。Xsession通过启动窗口管理器、任务栏，设定应用的默认值、安装标准键绑定
		等来启动整个桌面环境。KDE和Gnome都有自己的启动脚本，这些通常不需要用户操心。

		Xsession会一直运行，直到用户退出(或者说，当Xsession运行结束后，用户就退出了)。窗口管理器( Window Manager)
		是Xsession启动的唯一的前台程序(其他程序都在后台执行)，如果没有这个前台程序，那么用户会在登录后又立即退出
		系统。关于前、后台执行程序的区别，可参考5.8节的内容。
	启动X应用程序
		X窗口的服务器/客户机架构意味着一台主机上的X应用程序可以在另一台主机的屏幕上显示出来。X服务器接受来自
		多个应用程序的请求，然后在本地显示。而这些应用程序可能正运行在网络中的另几台主机上。
		
		也就是说，为了运行一个X应用程序，必须指定在什么地方显示。环境变量DISPLAY定义了这些内容。下面给出了一
		个DISPLAY变量的典型设置:
		
			DISPLAY=servername:3.2 
			
		当X应用程序启动时，它会查看这个环境变量。在上面这个例子中，X应用程序把自己的图形输出到主机servername
		上的显示3和屏幕2上。“显示3和屏幕2”这个短语有点难懂。如果一台主机只运行一个X服务器，那么这个X服务器就
		工作在端口6000， 对应的显示号是0;如果再安装一个X服务器程序，那么这个新的X服务器会工作在端口6001，对应
		的显示号是1，依次类推。至于“屏幕2”，说的是在一台主机上连接有多台显示器的情况下，显示器也从0开始编号。
		第1台显示器标识为“屏幕0”，因此“屏幕2”就是这台主机所连接的第3台显示器。

		由于大部分主机只运行一个X服务器，连接一台显示器，因此大部分情况下，环境变量DISPLAY的值会像下面这样: 
		
			servername:0.0

		现在再回过来考虑最常见的情况一X客户机(X应用程序)向本地的X服务器传递图形输出，X服务器在本地的显示器
		上显示图形。此时就不再需要指定服务器名了，环境变量DISPLAY的值相应地退化为下面这样:
		
			:0.0
			
		由于屏幕号也可以省略(默认屏幕号为0)，因此在最简单的情况下，DISPLAY变量的值只是一个“:0”。
		
	桌面环境:KDE和Gnome谁更好
		KDE (K桌面环境)是用C++编写的，基于Qt库。这是刚从Windows或者Mac转过来的用户比较偏爱的桌面环境。
		对于热衷于定制桌面的用户而言，KDE可能是最好的选择。KDE为程序员提供了一套功能完备的开发工具，
		包括一个集成开发环境(IDE)，这使得程序员很容易在KDE上开发风格统一的应用程序。
		
		Gnome是用C语言写成的，基于GTK+widget库。同样地，Gnome也为开发人员提供了一套易于使用的开发工具。

第2篇 系统管理篇
	第5章 She11基本命令
	第6章 文件目录管理
	第7章 软件包管理
	第8章 磁盘管理
	第9章 用户与用户组管理
	第10章 进程管理

第5章 Shell基本命令
	Shell简介
		命令行和Shell。命令行指的是供用户输入命令的界面，本身只接受输入，然后把命令传递给命令解释器（Shell）。本质上讲，Shell是一个程序，它在用户和操作系统之间提供了一个面向行的可交互接口。用户在命令行中输入命令，运行在后台的Shell把命令转换成指令代码发送到操作系统。
	浏览硬盘
		选择home进入，这个目录中存放在系统中所有用户的主目录。
		主目录下存放着一些配置文件和用户的私人文件。用户主目录默认对其他用户关闭访问权限。
		到/etc目录下看看。这个目录存放着系统以及绝大部分应用软件的配置文件。查看一下fstab 这个文件，其中定义了各硬盘分区所挂载到的目录路径。
	命令行补全和通配符
		补全
			按Tab键一次补全，两次列出相关提示
		通配符
			“*”、“?”、“[]”
			“*”	匹配任意长的字符串
			“?” 匹配任意一个字符串 
			“[]”用于匹配出现在方括号内的字符。可用短线"-"指定一个字符集范围，包含上下界字符。
			如：1~9、字母a~z等
	查看目录和文件
		显示当前目录：pwd
		改变目录：cd
		列出目录内容：ls 、dir、vdir
			重：关注ls命令的参数
		查看文本文件：cat和more 
			cat命令用于查看文件内容，后跟文件名作为参数。cat可以跟多个文件名作为参数。当然也可以使用通配符。cat命令提供了-n选项，在每行前显示行号。
			$ cat -n stack.h
			cat命令会一次将所有内容全部显示在屏幕上。
			more命令可以一页一页地显示文件内容。more命令会在最后显示一个百分比，表示已显示内容占整个文件的比例。按下空格键向下翻动一页，按Enter键向下滚动- -行。按Q键退出。
		head和tail
			常用查看文件的命令是head和tail。分别用于显示文件的开头和结尾。可以使用-n参数来指定显示的行数。
		文本阅读工具：less
			less 命令提供了下面这些增强功能。
				使用光标键在文本文件中前后(甚至左右)滚屏;
				用行号或百分比作为书签浏览文件;
				实现复杂的检索、高亮显示等操作;
				兼容常用的字处理程序(如Emacs、Vim)的键盘操作;
				阅读到文件结束时less命令不会退出;
				屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。
				
			less 在屏幕底部显示一个冒号“:”等待用户输入命令。如果想向下翻一页，可以按下空格键。如果想向上翻一页，按下B键。也可以用光标键向前、后、甚至左右移动。

			如果要在文件中搜索某一个字符串， 可以使用正斜杠“/”跟上想要查找的内容，less会把找到的第一个搜索目标高亮显示。要继续查找相同的内容，只要再次输入正斜杠“/”，并按下回车键就可以了。

			使用带参数-M的less命令可以显示更多的文件信息，less 在输出的底部显示了这个文件的名字、当前页码、总的页码，以及表示当前位置在整个文件中的位置百分比数值。最后按下Q键可以退出less程序并返回Shell提示符。
		查找文件内容：grep
			在文件中寻找某些信息，使用grep命令
			如：为了在文件day中查找包含un的行，可以使用如下命令:
				$ grep un day
			可指定多个文件搜索：$ grep un day weather
			查找多词，要用单引号将空格含进去：$ grep 'start list' stack.h
			相关工具egrep，可使用“扩展的正则表达式”。
			
	查找东西：find命令
		能迅速在指定范围内查找文件。如：在/usr/bin/目录中查找zip命令:
			$ find /usr/bin/ -name zip -print
			/usr/bin/	路径名 
			-name		选项指定了文件名，在这里是zip。可以使用通配符来指定文件名
			-print 		表示将结果输出到标准输出(在这里也就是屏幕)。
		find命令还能够指定文件的类型，使用-type选项来定位特殊文件类型。
			如：在/etc/目录中查找名叫init.d的目录:
			$ find /etc/ -name init.d -type a -print
			
			-type选项可以使用的参数：
				b 	块设备文件
				c 	字符设备文件
				d 	目录文件
				f 	普通文件
				p 	命名管道
				l 	符号链接
		指定时间来指导find命令查找文件。-atime n用来查找最后一次使用在n，天前的文件，-mtime n则用来查找最后一次修改在n天前的文件。但是在实际使用过程中，很少能准确确定n的大小。在这种情况下，可以用+n表示大于n，用-n表示小于n。例如，在/usr/bin/中查找最近100天内没有使用过的命令(也就是最后一次使用在100天或100天以前的命令)。
			$ find /usr/bin/ -type f -atime +100 -print

	快速定位文件：locate命令
		locate 并没有进入子目录搜索，它通过检索文件名数据库来确定文件的位置。locate命令自动建立整个文件名数据库，不需要用户插手。如果希望立刻生成该数据库文件的最新版本，那么可以使用updatedb命令。运行这个命令需要有root权限，更新整个数据库大概耗时1分钟。

	从终端运行程序
		从终端运行程序只需要简单地键入程序名称即可。像ls、find、 locate 等这些所谓的Linux命令都只是一些程序而已。类似地，可以这样启动网页浏览器firefox.
			$ firefox
		按Enter键之后，当前终端会被挂起，直到firefox运行完毕(即单击关闭按钮)。如果希望在启动应用程序后继续在终端模拟器中工作，需要在命令后加上“&”，指导程序在后台运行。
	查找特定程序：whereis
		whereis命令主要用于查找程序文件，并提供这个文件的二进制可执行文件、源代码文件和使用手册页存放的位置。例如，查找find命令:
			$ whereis find
			find: /usr/bin/ find /usr/ share/man/man1/ find.1.gz
		可以使用-b选项让whereis命令只查找这个程序的二进制可执行文件。
			$ whereis -b find
			find: /usr/bin/ find
		如果whereis无法找到文件，那么将返回一个空字符串。
		whereis无法找到某个文件的可能原因是，这个文件没有存在于任何whereis命令搜索的子目录中。whereis命令检索的子目录是固定编写在它的程序中的。这看起来多少有点像是个缺陷，但把搜索限制在固定的子目录如/usr/bin、/usr/sbin 和/usr/share/man中可以显著加快文件查找的进度。
	用户及版本信息查看
		who命令可以查看当前系统中有哪些人登录，以及他们都工作在那些控制台上。
		whoami命令查看“我是谁？”
		uname命令显示当前系统的版本信息。带-a选项显示当前系统的所有信息；带-r只显示内核版本信息。
	帮助命令：man
		使用man命令可以方便地获取某个命令的帮助信息。
		man命令在显示手册页时实际调用的是less程序。可以通过方向键或J键(表示向下)、K (表示向上)键上下翻动。空格键用于向下翻动一页。按下Q键则退出手册页面。man 手册一般被分成9节，疑问？？？？？
	获取命令简介：whatis和apropos
		whatis从某个程序的使用手册页中抽出一行简单的介绍性文字，帮助用户了解这个程序的大致用途。whatis 的原理同locate 命令基本一致。
		apropos,这个命令可以通过使用手册中反查到某个命令。举例，如果用户想要搜索一个文件，而又想不起来应该使用哪个命令的时候，可以这样求助于apropos。
			$ apropos search
		apropos 将命令简介(其实就是whatis的输出)中包含“search” 的条目一并列出，用户总能够从中找到自己想要的。

第6章 文件目录管理
	Linux文件系统的架构
		Linux没有“盘符”的概念，也就是说Linux系统不存在所谓的C盘、D盘等。已建立文件系统的硬盘分区被挂载到某一个目录下，用户通过操作目录来实现磁盘读写。其次，Linux 似乎不存在像Windows\这样的系统目录。在安装完成后，就有一堆目录出现在根目录下，并且看起来每-一个目录中都存放着系统文件。最后一个小小的区别是，Linux 使用正斜杠“/” 而不是反斜杠“\”来标识目录。
		Linux需要首先建立一个根“/”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的文件系统挂载到这些目录中。
		如果某些目录没有特定的硬盘分区与其挂钩的话，该目录中的所有内容将存放在根分区中。
		注：文件系统的概念？？？
		 
	Linux文件系统中主要目录
		/bin	构建最小系统所需要的命令(最常用的命令)
		/boot	内核与启动文件
		/dev	各种设备文件
		/etc	系统软件的启动和配置文件
		/home	用户的主目录
		/lib	C编译器的库
		/media	可移动介质的安装点
		/opt	可选的应用软件包(很少使用)
		/proc	进程的映像
		/root	超级用户root的主目录
		/sbin	和系统操作有关的命令
		/tmp	临时文件存放点
		/usr	非系统的程序和命令
		/var	系统专用的数据和配置文件

	创建共享文件
		假设这个团队的成员在服务器上的用户名分别是lucy、lewis、mike和peter,它们都属于workgroup这个用户组可以用以下的命令模拟这个场景。
			##新建一个名为workgroup的用户组
			$ sudo groupadd workgroup
			##新建用户，并归入workgroup组
			$ sudo useradd -G workgroup lucy
			$ sudo | passwdlucy					##为用户lucy设置登录密码
			$ sudo useradd -Gworkgroup lewis
			$ sudo passwd lewis					##为用户lewis设置登录密码
			$sudo useradd-G workgroup mike
			$ sudo passwd mike					##为用户mike设置登录密码
			$用sudo useradd -G workgroup peter
			$ sudo passwd peter					##为用户peter设置登录密码
		首先在/home目录下建立-一个名为work的目录，作为这个小组的工作目录，注意需要root权限。
			$ cd /home							##切换到/home目录
			$ sudo mkdir work					##建立一个名为work的目录
		现在，任何人都可以访问这个新建的目录，而只有root用户才拥有该目录的写权限。现在希望让workgroup组的成员拥有这个目录的读写权限，并禁止其他无关的用户查看这个目录。
			$ sudo chgrp workgroup work/ 		##将work目录的所有权交给workgroup组
			$ sudo chmod g+rwx work/			##增加workgroup组对work目录的读、写、执行权限
			$ sudo chmod o-rwx work/			##撤销其他用户对work目录的读、写、执行权限
		接下来需要将这个目录交给-一个组 长lewis (现在work目录的所有者还是root用户)。
			$ sudo t chown lewis work/			##将work目录的所有者更改为lewis用户
		现在，所有属于这个组的成员都可以访问并修改这个目录中的内容了，而其他未经授，权的用户(除了root)则无法看到其中的内容。

	建立文件和目录
		建立目录：mkdir
			可一次创建多个文件夹，或连续创建文件夹
			如：
				$ mkdir document picture
				$ mkdir -P ~/tempx/job
				
		建立一个空文件：touch
			touch命令后跟文件名，即可创建空文件。如：$ touch hello
			touch命令可以更新一个文件的建立日期和时间。如：$ touch test.php
			touch命令在自动备份和整理文件时非常有用。
		
		移动和重命名
			将hello文件移动到bin目录下：$ mv hello bin/
			把Photos目录移动到桌面：$ mv photos/ 桌面/
			注：mv会替换目录中的同名文件，而且没有提示
			mv -i XXX 可以在出现同名文件时给出提示
			mv -b XXX 可以在出现同名文件后，在目标文件中同名文件前加“~”备份。
			重命名文件：$ mv hello~ hello_bak
		
		复制文件和目录：cp
			将文件test.php复制到test目录下：$ cp test.php test/
			注：cp默认覆盖目标目录中的同名文件，加-i进行提示；加-b备份同名文件；
				加-r可以连同目录和子目录复制到另一目录中
				$ cp test/ 桌面/
				cp：略过目录“test/”
				
		删除目录和文件：rmdir和rm
			rmdir命令用于删除目录：$ mkdir remove
			rmdir命令只能删除空目录，所以不常用
			rm命令可以一次删除一个或几个文件。删除test目录下所有的php文件：$ rm test/*.php
			注：rm命令不会作任何提示，也不会过“回收站”，所以尽量使用-i选项给出提示。
				-f可以避免自读文件的交互，默认选择y；
				-r会递归删除目录下所以文件和子目录
			删除还有delete命令？？？？？
				
	文件和目录的权限
		权限设置针对的用户
			文件所有者、文件属组用户、其他人
			文件所有者通常是文件的创建者，但这也不是一定的。可以中途改变一个文件的属主用户，这必须直接由root 用户来实施。
		需要设置哪些权限
			文件和目录的3种权限:读取(r)、写入(w)和执行(x)。
			对于文件而言，拥有读取权限意味着可以打开并查看文件的内容，写入位控制着对文件的修改权限。而是否能够删除和重命名一个文件则是由其父目录的权限设置所控制的。
			要让一个文件可执行，必须设置其执行权限。可执行文件有两类，一类是可以直接由CPU执行的二进制代码;另一类是Shell脚本程序。
			对目录而言，所谓的执行权限实际控制了用户能否进入该目录;而读取权限则负责确定能否列出该目录中的内容;写入权限控制着在目录中创建、删除和重命名文件。因此目录的执行权限是其最基本的权限。
		查看文件和目录的属性
			查看文件的属性：$ ls -l /bin/login
			查看目录的属性：$ ls -ld /etc/
				$ ls -l /bin/login
				-rwxr-xr-x 1 root root 38096 2008-11-13 14:54 /bin/login
				解析：
					“-” 			是文件类型，“-”表示普通文件
					“rwxr-xr-x”		表示3组权限，rwx、r-x、r-x表属主、属组、其他人，某个权限禁用“-”表示
					“1”				该文件的连接数目。（软连接，硬连接）
					“root”			属主
					“root”			属组
					后面是文件大小、日期、时间、文件路径
			改变文件所有权：chown和chgrp
				chown命令用于改变文件多有权。将文件days的属主改为lewis，把属组改为root：
					$ sudo chown lewis:root days 
				把days文件的属主改为guest用户，保留属组：
					$ sudo chown guest days
				把days文件属组改为nogroup组，保留属主：
					$ sudo chown :nogroup days		## ":"冒号不能省略
				chown命令的-R选项，用于改变一个目录及其下所有文件和子目录的所有权。
				
				chgrp命令用于设置文件的属组。将文件days的属组设置为nogroup组：
					$ sudo chgrp nogroup days
					chgrp命令也可使用-R参数，进行循环设置
					
			改变文件权限：chmod
				这个命令使用“用户组+、-权限”的表达方式来增加、删除相应权限。
				用户组包括文件属主(u)、文件属组(g)、其他人(o)和所有人(a)；权限则包括了读取(r)、写入(w)和执行(x)。
					如：增加了属主对文件days的执行权限：$ chmod u+x days
						删除所有人对days的执行权限：$ chmod a-x days
				可以通过“用户组=权限”方式设置文件权限。
					如：赋予属主和属组的读取/写入权限，赋予其他用户读取权限
						$ chmod ug=rw,o=r days
				常用规则“用户组1=用户组2”，使两个组权限一致
					如：将其他人的权限设置为何属主的一样：
						$ chmod o=u days
			
			文件权限的八进制表示
				如：rwx表示为111，“-w-” 表示为010。
				另外：1代表x，2代表w，4代表r
				如：“rwxr-x--x”表示为“751”：$ chmod 751 prog
			
			文件类型
				7种文件类型如下：
					“-”		普通文件
					“d”		目录 
					“c”		字符设备文件
					“b”		块设备文件
					“s”		本地域套接口
					“p”		有名管道
					“l”		符号链接
				Linux中有两类设备文件:字符设备文件和块设备文件。字符设备指的是能够从它那里读取成字符序列的设备，如磁带和串行线路;块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备，如磁盘。
				本地域套接口和有名管道都是有关进程间通信的。
				符号链接有点像Windows里的快捷方式，用户可以通过别名去访问另一个文件。
				拥有某个设备文件并不意味着一定有一个相对应的硬件设备存在，这只是表明Linux有处理这种设备的“潜能”。设备文件可以用mknod命令来创建。???????

		建立链接：ln
			符号链接（软链接）需要使用带-s参数的ln命令来创建。如：给目标文件TARGET取一个别名LINK_NAME：
				$ ln -s TARGET LINK_NAME
				示例：
				$ 1n-s days my_ days	##建立一个名为my_ days的符号链接指向文本文件days
				$ ls-l my_ days			##查看my_days的属性
				lrwxrwxrwx 1lewis lewis 4 2008-12-13 22:15 my days -> days
				从my_days的属性中可以看到，这个文件被指向days。从此访问my_days就相当于访问days。
				my_days只是文件days的一个“别名”，因此删除my_days并不会影响到days。但如果把days删除了，那么my_ days 虽然还保留在那里，但已经没有任何意义了。
			符号链接还可以用于目录。	

			“硬链接”用于将两个独立的文件联系在一起。硬链接是直接引用，而符号链接是通过名称进行引用。
			创建“硬链接”：$ ln days hard_days
			这条命令建立了一个链接到days的新文件hard_days。查看两者的属性可以看到，这是两个完全独立的文件，只是被联系在一起了而已。
				$ ls -1 days
				-rWx--x--X 2 lewis nogroup 57 2008-11-24 17:00 days
				$ls-l hard_days
				-rWx--x--x 2 lewis nogroup 57 2008-11-24 17:00 hard_days
			这两个文件拥有相同的内容，对其中一个文件的改动会反映在另一个文件中。
			实际工作中，符号链接（软链接）常用，硬链接很少用
	
	输入输出重定向和管道
		输出重定向
			程序在默认情况下输出结果的地方被称为标准输出(stdout)。通常来说，标准输出总是指向显示器。如：ls命令的输出
			输出重定向用于把程序的输出转移到另一个地方去。如：将ls的输出重定向到lsout文件中。
				$ ls > ~/ls_out
			这样，ls的输出就不会在显示器上显示，而是输出到ls_out文件中。
			注：如ls_out文件不存在，重定向符号”>“会创建文件；如果存在，会删除原文件内容，插入新内容；
				如果要新增内容，就使用符号“>>"
		输入重定向
			和标准输出类似，程序默认情况下接收输入的地方被称为标准输入(stdin)。通常来说，标准输入总是指向键盘。例如，如果使用不带任何参数的cat命令，那么cat会停在那里，等待从标准输入(也就是键盘)获取数据。
			用户的每一行输入会立即显示在屏幕上，直到使用Ctrl+D快捷键提供给cat命令一个文件结束符。
			通过使用输入重定向符号“<”可以让程序从一个文件中获取输入。
				如：$ cat < days
			将文件days作为输入传递给cat命令，cat读取days中的每一行，然后输出读到的内容。最后当cat遇到文件结束符时，就停止读取操作。
			实际上，“cat<days”可以用“cat days”替代，所有输入重定向不常用。
			
			立即文档，操作符“<<”。如；
				$ cat << EOF
				> Hello
				> Bye
				> EOF 
			立即文档定义了结束符（“EOF”），当shell遇到这个单词，就任务输入结束。立即文档输入的信息，会在结束时，一次性显示出来。立即文档的结束符，可以任意定义。
			让输入重定向和输出重定向结合使用：$ cat << END > hello
			使用立即文档获取输入，遇到END后结束输入，打印输入，并将信息重定向到hello文件中。
		管道：|
			管道“|”,将一条命令的输出连接到另一命令输入。如：在文件列表中查找文件名包含特定字符串的文件。
				$ ls | grep ay

第7章 软件包管理
	软件包是将应用程序、配置文件和管理数据打包的产物。特定的软件包管理系统可以方便地安装和卸载软件包。常用的软件包格式有两种RPM、deb。SUSE、 Red Hat、Fedora 等发行版本使用RPM，而Debian和Ubuntu则使用.deb格式的软件包。
	安装和卸载Chrome for Linux
		安装
			Debian和Ubuntu用户
			$ sudo dpkg -i google-chrome-stable_current.deb   ## 安装Chrome for Linux 
			RPM软件包用户
			$ su			## 切换到root用户
			# rpm -ivh google-chrome-stable_current.rpm 	  ## 安装Chrome for Linux 
		卸载
			一般说，卸载软件包需要提供完整的软件包名称或版本。如果无法提供，可以查找这些信息
			Debian和Ubuntu用户
				$ dpkg -l | grep chrome  			## 查找软件包名称
				$ sudo dpkg -r google-chrome-stable ## 卸载软件
			RPM软件包用户
				$ rpm --query chrome 				## 查找软件包名称
				$ su
				# rpm -e google-chrome-stable 		## 卸载软件
	管理deb软件包：dpkg
		主要用于Debian和Ubuntu，可通过dpkg-help获得完整帮助信息。
		安装软件包
			dpkg使用--install选项安装软件，可简写为-i。软件包安装前必须保证其依赖的库和支持构造已安装在系统中。
		查看已安装的软件包
			$ dpkg -l | grep openssh
			或使用--search选项（简写为-S）
			$ dpkg -S openssh
		卸载软件包
			使用dpkg的--remove选项（简写-r）
			$ sudo dpkg --remove opera
	管理RPM软件包：rpm		
		安装软件包
			使用rpm -i即可安装，-v显示rpm当前正在执行的工作；-h提示安装进度
				$ sudo rpm -ivh  dump-0.4b41.rpm
		升级软件包
			rpm -U升级软件包，可使用-v、-h参数。
				$ sudo rpm -Uvh dump-0.4.rpm  ##如果已安装了dump较早版本，这是升级到0.4版本
		查看已安装软件包
			rpm -q命令可查询已安装的软件包。$ rpm -q check
				$ rpm -qa	## 列出当前系统已安装的所有软件包
				$ rpm -qa | grep xorg ## 查找自己想要的软件包
		卸载软件包
			$ sudo rpm -e tcpdump	## 卸载软件包tcpdump
			有时可能会因为软件包被多个包依赖，rpm拒绝卸载，可使用--nodeps强制卸载，不建议使用
			$ sudo rpm -e -vv --test xorg-x11-devel		## 输出rpm完整的调试信息
	高级软件包工具：APT
		rpm和dpkg软件包管理器，不能解决依赖性问题，所有APT、yum才出现
		常用指令
			apt-get install		下载并安装软件包
			apt-get update		下载并安装在本系统上已有的软件包的最新版本
			apt-get remove		卸载特定的软件包
			apt-get source		下载特定的软件源代码
			apt-get clean		删除所有已下载的包文件
			apt-get -h 			apt-get的完整用法
			
			$ apt-cache search flight	## 搜索带“flight”字样的软件包
			$ apt-cache depends flightgear ## 查询flightgear的依赖关系
		配置apt-get
			apt-get用于下载软件的地址，称为安装源，放在/etc/apt/sources.list中
			解释一下sources.list中字段的含义。
				1、deb和deb-src:表示软件包的类型。Debian 类型的软件包使用deb或deb-src。如果是RPM的软件包，则应该使用rpm或rpm-src。其中,src表示源代码。
				2、URL:表示指向CD-ROM、HTTP或者FTP服务器的地址，从哪里可以获得所需的软件包。
				3、hardy等:表示软件包的发行版本和分类，用于帮助apt-get遍历软件库。
				4、“#”号开头的是注释
		使用图形化的APT
			略  
	源代码编译软件--MPlayer
		下载和解压软件包
			可以从www.mplayerhq.hu/design7/dload.html上下载到最新版的MPlayer。源代码是MPlayer-1.1.tar.gz。如果希望使用图形界面的话，还需要下载MPlayer的皮肤。这里使用的是默认的BlueSkin。在Linux 的世界里，“.tar.bz2”和“.tar.gz”这样的压缩格式是发布源代码的标准格式，使用下面的命令解压这两个压缩包。
				$ tar zxvf Mplayerr-1.1.tar.gz   ##解压缩
		正确配置软件
			Linux上所有的软件都使用configure 这个脚本来配置以源代码形式发布的软件。configure依据用户提供相关参数生成对应的makefile文件，后者指导make命令正确地编译源代码。
			几乎所有的configure脚本都提供了--prefix这个选项，用于指定软件安装的位置。如果用户不指定，那么软件就按照其默认的路径设置安装自己。下面这条命令指定将软件安装在/usr/local/games/foobillard目录下。
				$ ./configure --prefix=/usr/local/games/foobillard
				注：将软件安装在/usr/local 目录下是个好习惯，可以同/usr目录下系统工具区分开
			至于configure的其他选项，就需要借助软件安装文档了，通常是README或INSTALL
			进入MPlayer-1.1目录，$ cat README 查看文档，MPlayer的configure脚本提供了--enable-gui选项启动图像界面，配置如下：
				$ ./configure --enable-gui 		##执行configure脚本
		编译源代码
			编译源代码执行make命令
				$ make 
			make是一种高级编译工具,它可以依据makefile文件中的规则调用合适的编译器编译源代码。
		安装软件到硬盘
			$ sudo make install 	##以root身份安装软件
			注：查看帮助文档，安装皮肤
		出错怎么办
			$ gmplayer & 		## 以图形方式启动MPlayer
			报错，耐心分析下错误信息，参照帮助文档，基本上就能解决问题。也可以搜下错误信息。

第8章 磁盘管理
	硬盘 
		新配的电脑全是SATA硬盘，也就是串口硬盘。
	Linux文件系统 
		文件系统是一种对物理空间的组织方式，通常格式化硬盘时创建。Windows下有NTFS和FAT两种；Linux下有多种：
		ext3fs和ext4fs文件系统
			ext4fs是对ext3fs的扩展和改善，ext4fs增加了日志功能，保证了文件系统的可靠性。
			ext4fs 文件系统预留了一块专门的区域来保存日志文件，当对文件进行写操作时，所作的修改将首先写入日志文件，随后再写入一条记录标记日志项的结束。完成以上这些操作后，才会对文件系统作实际的修改。这样，当系统崩溃后，就可以利用日志恢复文件系统，在最大程度上避免了数据的丢失。
		ReiserFS文件系统
			Linux内核从2.4.1 版本开始支持ReiserFS。
			ReiserFS 也是一种日志文件系统，从而免去了对系统崩溃、意外断电等特殊事件的担忧。除此之外，ReiserFS 第4版还加入了模块化的文件系统接口，这个功能对于开发人员和系统管理员而言会比较有用，它可以在特殊环境里增强文件的安全性。
			在算法空间效率上，Reiser4 无疑比以前做的更好。Reiser4 的新算法可以同时兼顾速度和磁盘利用率，而其他文件系统往往需要系统管理员在这两个方面进行选择。
		有关swap
			swap被称为交换分区。这是- -块特殊的硬盘空间，当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。
			具体使用多大的swap分区取决于物理内存大小和硬盘的容量。一般来说，swap分区容量应该要大于物理内存大小，但目前不能超过2GB。
	挂载文件系统
		使用光盘
			对光盘进行手动挂载。通常，光盘插入驱动器后，桌面上会出现驱动器图片，打开图标就能读取光盘。
			我们将光盘挂载到另一个目录下：
				$ sudo mkdir /mnt/cdrom				##/新建一个目录
				$ sudo mount /dev/cdrom /mnt/cdrom/	##挂载光盘至这个新建的目录
				mount:块设备/dev/scd0写保护，以只读方式挂载
			现在，可以通过目录/mnt/cdrom访问这个光盘了。
				$ cd /mnt/cdrom/
				$ ls		##查看光盘内容
				autorun.inf		dists	isolinux	pics preseed	ubuntu	wubi.exe
				casper	install md5sum.txt  pool  README.diskdefines umenu.exe
			使用完成后，需要取出光盘，可以运行如下命令:
				$ cd /	##退出/mnt/cdrom目录
				$ sudo umount /dev/cdrom	##卸载光盘
			注:卸载光盘前必须先退出光盘所挂载到的那个目录(这里是/mnt/cdrom)，否则系统会提示设备忙并拒绝卸载。
		Linux下设备的表示方法
			Linux下所有的设备都被当作文件来操作，每个设备都被映射为一个特殊文件，这个文件被称作“设备文件”。对;于上层应用程序而言，所有对这个设备的操作都是通过读写这个文件实现的。Linux 把所有的设备文件都放在/dev目录下。
			/dev目录中大部分是块设备文件和字符设备文件。块设备(例如磁盘)可以随机读写，/dev/hda1、/dev/sda2 等就是典型的块设备文件;而字符设备只能按顺序接受“字符流”，常见的有打印机等。
			Linux下硬盘有种特殊的命名规则。用户不能直接通过设备文件访问存储设备，所有的存储设备(包括硬盘、光盘等)在使用之前必须首先被挂载到一个目录下，然后就可以像操作目录一样使用这个存储设备了。
		挂载文件系统：mount命令
			几乎可挂载所有设备。示例：
				$ sudo mkdir /mnt/vista				##新建一个目录
				$ sudo mount /dev/sda3 /mnt/vista/	##将Windows所在的分区挂载到这个目录中
				$ cd /mnt/vista/
				$ ls
			参数-t选项可指明设备所使用的的文件系统类型。如不指明会自动检测，一般不需要此参数。文件系统表示如下：
				表示方法			描述
				ext2			Linux的ext2文件系统
				ext3			Linux的ext3文件系统
				ext4			Linux的ext4文件系统
				vfat			Windows的FAT16/FAT32文件系统
				ntfs			Windows的NTFS文件系统
				iso9660			CD-ROM光盘的标准文件系统
			参数-r和-w，只读模式和可读写模式挂载设备。其中-w选项是默认值。
				$ sudo mount -r /dev/sda3 /mnt/vista/	##以只读方式挂载硬盘分区
		在启动的时候挂载文件系统：/etc/fstab文件
			系统如何在开机时挂载硬盘?系统又是怎样知道哪些分区是需要挂载的? Linux通过配置文件/etc/fstab来确定这些信息，这个配置文件对于所有用户可读，但只有root用户有权修改该文件。
			fstab表的各个纵列依次表示如下含义:
				1、用来挂装每个文件系统的UUID (用于指代设备名) ;
				2、挂载点;
				3、文件系统的类型;
				4、各种挂装参数;
				5、备份频度(将在本章“进阶”部分具体讨论) ;
				6、在重启动过程中文件系统的检查顺序。
				注：Ubuntu使用UUID来标识文件系统，而openSUSE等发行版本则直接使用设备文件的路径作为每一行的第 1个字段。
			注意exec参数。这个参数允许任何人运行该设备上的程序。这对于CD-ROM设备非常重要，否则用户将不得不一次次地求助于管理员，原因可能只是无法启动自己光盘上的程序。
			下列有几个常用选项的含义。这些选项也可以紧跟在mount的-o参数后面使用。
				auto				开机自动挂载
				default, noauto		开机不自动挂载
				nouser				只有root可挂载
				ro					只读挂载
				rW					可读可写挂载
				user				任何用户都可以挂载
		卸载文件系统
			umount命令后跟设备名即可卸载。
			注：1、在无法卸载时，可用-r参数，尝试以只读方式重新载入，然后卸载
			    2、当前目录是被挂载目录时，卸载时不允许的，卸载时要切换到其他目录
	查看磁盘使用情况：df
		df命令会收集和整理当前已经挂载的全部文件系统的一些重要的统计数据。这个命令使用起来非常简单。
			$ df
		df命令提供了-t参数用于显示特定的文件系统。
			$ df -t ext4 		##显示所有已挂载的ext4文件系统
	检查和修复文件系统：fsck
		当系统发生异常，对于ext4fs和ReiserFS这样的日志文件系统，fsck可以以惊人的速度执行检查，并将日志回滚到上一次正常的状态中。fsck 接受分区编号(如/dev/sda5)来指定需要检查的文件系统。
			$ sudo fsck /dev/sda1
		带有-p选项的fsck命令会读取fstab 文件来确定检查哪些文件系统，并通过每一条记录最后一个字段所指定的顺序，对文件系统按照数字的升序进行检查。如果两个文件系统的序号相同，那么fsck会同时检查它们。通常情况下，fsck -p会在硬盘启动时自动运行。
			$ sudo fsck -P		##根据fstab文件来检查文件系统
	新建文件系统：mkfs
		所有的磁盘在使用前都必须经过格式化。格式化就是在目标盘上建立文件系统的过程。mkfs命令用于完成这一操作。
		mkfs本身并不执行建立文件系统的工作，而是调用相关的程序。通过使用-t参数指定文件系统，mkfs 会调用特定的程序对磁盘进行格式化。
		常用文件系统：	
			minix		Linux最早期使用的文件系统
			ext3		ext3文件系统
			ext4		ext4文件系统(默认值)
			msdos		FAT文件系统
		将第2块硬盘的第1个分区(sdb1) 格式化为ext4格式。
			$ sudo mkfs -t ext4 /dev/sdbl		##格式化/dev/ sdb1
		使用-c选项来检查指定设备上损坏的块。
			$ sudo mkfs -t ext4 -c /dev/sdb1	##检查/dev/ sdb1
	使用USB设备
		一般情况，Linux会自动挂载接入USB接口设备。
		手动挂载。USB设备在Linux中被认为是SCSI设备，因此可以从/dev/sd[a-z]1-..]挂载。如果系统中的硬盘是IDE接口的话，那么USB设备被识别为第1块SCSI设备，即sda;如果系统中有一块SCSI硬盘的话，那么USB设备被识别为第2块SCSI设备，即sdb。依次类推。简而言之，Linux会将USB设备识别为第一个没有被硬盘占用的SCSI设备。
			$ sudo mkdir /mnt/usb		##新建一个目录用于挂载usb设备
			$ sudo mount /dev/sdb1 /mnt/usb/	##挂载usb设备
			$ cd /mnt/usb/
			$ ls						##列出usb设备(U盘)中的内容
			desktop.dlljava linux book便photo vmware-serial -numbers
			$ cd/						##离开所挂载的目录
			$ sudo umount / dev/ sdb1	##卸载该usb设备
		另外，使用lsusb命令可以列出当前内核已经发现的USB设备。
			$ lsusb
	压缩工具
		压缩文件：gzip
			$ gzip linux_book_bak.tar	## 压缩文件linux_book_bak.tar成linux_book_bak.tar.gz
			要解压缩.gz文件，可以使用gunzip命令或者带“-d” 选项的gzip命令。
				$ gunzip linux_ book_ bak. tar.gz
				或者 
				$ gzip -d linux_ book_ bak. tar.gz
			需要解压的文件有合适的扩展名。gzip(或者gunzip)支持的扩展名有.gz、.Z、-gZ、.z、 -Z 和Z。
			-i选项用于查看压缩效果，文件的大小以字节为单位。
				$ gzip -i linux_ book_ bak. tar.gz
			-t选项可以用来测试压缩文件的完整性。文件正常，不会给出任何显示。如果一定要让gzip说点什么，可以使用-tv选项。
				$ gzip -tv linux_ book_ bak. tar.gz
		更高压缩率：bzip2
			bzip2的使用方法同gzip基本一致。
				$ bzip2 1 inux_book_bak.tar
			解压缩.bz2文件可以使用bunzip2或者带-d选项的bzip2命令:
				$ bunzip2 linux_book_bak.tar.bz2
				或者
				$bzip2 -d linux_book_bak.tar.bz2
			bzip2识别格式有.bz2、.bz、.tbz2、.tbz和bzip2。使用bzip2压缩的文件改了名字，解压后文件名后面会多出一个“.out”作为扩展名。
			-tv选项检查压缩文件的完整性。
				$ bzip2 -tv linux_book_bak.tar.bz2
		支持rar格式
			在Linux下处理rar 文件可以使用RAR for linux。 这是一个命令行工具，可以从www.rarlab.com/download.htm上下载。
			要解压一个文件,只要简单地使用命令rar和选项x。
				$ rar x music.rar	##解压缩music. rar
	存档工具
		文件打包：tar
			将Shell目录连同其下的文件一同打包成文件shell.tar。
				$ tar -cvf shell.tar shell/
				c指导tar创建归档文件，
				v用于显示命令的执行过程
				f则用于指定归档文件的文件名，在这里把它设置为“shell.tar” 。
				最后一个(或者几个)参数指定了需要打包的文件和目录(在这里是shell目录)。
			和gzip不同，tar不会删除原来的文件。
			解开.tar文件，只要简单地把-c选项改成-x (表示解开归档文件)就可以了。
				$ tar -xvf shell.tar
			tar -w选项，用于每次将单个文件加入(或者抽出)归档文件时征求用户的意见。回答y表示同意，n表示拒绝。
				$ tar -cvwf shell.tar shell/
			tar -z，会自动调用gzip程序完成操作。创建归档文件时，tar 程序在最后调用gzip 压缩归档文件;解开归档文件时，tar 程序先调用gzip解压缩，然后再解开被gzip处理过的.tar文件。
				如：将Shll目录打包，并调用gzip程序处理打包后的文件。
				$ tar -czvf shell.tar.gz she11/
				相当于
				$ tar -cvf shell.tar shell/
				$ gzip shell.tar
			下面的命令首先调用gunzip解压shell.tar.gz,然后再解开shell.tar(注意这里省略了-v选项，这样tar只是默默地完成工作，不会有任何输出)。
				$ tar -xzf shell.tar.gz
				相当于
				$ gunzip shell.tar.gz
				$ tar -xf shell.tar
			tar -j参数用于调用bzip2程序，这个参数的用法同-z完全一致。下面这条命令用于解开shell.tar.bz2。
				$ tar -xjf shell.tar.bz2
		转义文件：dd
			dd命令曾经广泛地用于复制文件系统。dd的if选项指定输入端的文件系统，of选项则指定其输出端。下面这条命令将一张CD完整地转储为iso镜像文件。
				$ dd if=/dev/cdrom of=CD.iso
	进阶1：安装硬盘和分区：fdisk
		使用fdisk建立分区表
			新增一块SCSI硬盘。第1块SCSI硬盘表示为sda,而第2块SCSI硬盘叫sdb。在/dev目录下看到下面的内容。
				$ ls /dev/ | grep sd	##查看/dev目录中以“sd”开头的文件
					sda
					sdal
					sda2
					sdb
			第一块SCSI硬盘sda已经有了2个主分区sdal和sda2，新增硬盘，并没有建立分区表。下面将在sdb上建立3个分区，并在第1个和第3个分区上建立ext3fs文件系统，把第2个分区留作swap交换分区。
			先切换到root身份，输入su（ubnuntu用户使用sudo -s）
			启动fdisk程序，并以目标设备作为参数。
				# fdisk /dev/sdb
				注：fdisk是一个交互式的应用程序。fdisk会显示一行提示信息，并给出一个冒号“:” 等待用户输入命令，就像Shell一样。使用命令m可以显示fdisk所有可用的命令及其简要介绍。
				常用命令：
				 命令全称		缩写形式		含义
					new			n				创建一个新分区
					print		p 				显示当前分区设置
					type 		t				设置分区类型
					write		w 				把分区表写入硬盘
			创建第1个分区。为了方便，全部创建成主分区。
				Command (m for help) : new					##新建一个分区
				Command action
					e extended
					p primary partition (1-4)
				p											##设置为主分区
				Partition number (1-4) : 1					##设置为第1个主分区
				First cylinder (1-652， default 1) : 1		##分区从硬盘的第1个柱面开始
				Last cylinder or +size or +sizeM or +sizeK (1-652， default 652) : +2G
															##设置分区容量(2GB)
			现在查看一下分区表的设置，以保证设置正确。
				Command (m for help) : print
								
				Disk /dev/sdb: 5368 MB, 65368709120 bytes
				255 heads, 63 sectors/track, 652 cylinders ;
				Units = cylinders of 16065 * 512 = 8225280 bytes
				Disk identifier: 0x04e762ac

				Device Boot		Start	End		Blocks		Id		System
				/dev/sdb1		1		244 	1959898+	83 		Linux
			创建第2个分区，用作swap交换。swap分区最大不能超过2GB，这里给它划分1GB的容量。
				Command (m for help) : new						##新建一个分区
				Command action
					e extended
					p primary partition (1-4)
				p												##设置为主分区
				Partition number (1-4) : 2						##设置为第2个主分区
				First cylinder (245-652, default 245) : 245 	##紧接着上一个分区结束的位置开始
				Last cylinder or +size or +sizeM or +sizeK (245-652， default 652) : +1G
																##设置分区容量(1GB)
			改变这个分区的类型，使其成为swap分区(而不是默认的Linux分区)。
				Command (m for help) : type				##修改分区类型
				Partition number 6 (1-4) : 2			##设置需要修改的对象(2号分区)
				Hex code (type L to list codes) : 82 	##设置为82号(swap)分区类型
				Changed system type of partition 2 to 82 (Linux swap / Solaris)
				注：分区类型号82是swap分区类型。如记不住这些数字，可使用命令L查看分区类型及其编号。
				Hex code (type L to list codes) : L
			最后设置第3个分区，这个分区使用剩余的所有硬盘空间。
				Command(m for help) : new
				Command action
					e extended
					p primary partition (1-4)
				p
				Partition number (1-4) : 3
				First cylinder (368-652，default 368) :		##直接回车使用默认值
				Using default value 368
				Last cylinder or +size or +sizeM or +sizeK (368-652， default652) :
															##直接回车使用默认值(用尽剩余空间)
				Using default value 652
			完成所有3个分区的设置之后，再次调用print命令查看当前的分区信息。
				Command (m for help) : print
				
				Disk/dev/sdb: 5368 MB, 5368709120 bytes
				255 heads, 63 sectors/track, 652 cylinders
				Units= cylinders of 16065 * 512 = 8225280 bytes
				Disk identifier: 0x04e762ac
				
				Device Boot		Start	End		Blocks		Id		System
				/dev/sdb1		1		244		1959898+	83 		Linux
				/dev/sdb2		245		367		987997+ 	82		Linux swap / Solaris
				/dev/sdb3		368		652		2289262+	83 		Linux
			使用write命令可以把分区信息写入硬盘。
				Command (m for help): write
				The partition table has been altered!
				
				Calling ioctl() to re-read partition table.
				Syncing disks.
			查看/dev目录，可以看到现在磁盘sdb.上已经有3个分区了。
				#1s /dev/ | grep sd		##查看/dev目录中以sd开头的文件
					sda
					sdal
					sda2
					sdb
					sdb1
					sdb2
					sdb3
		使用mkfs建立ext3fs文件系统
			创建完分区后，就需要在各个分区上建立文件系统。
			# mkfs -t ext3 /dev/sdb1	##在新硬盘的第1个分区上建立ext3fs文件系统
		使用fsck检查文件系统
			运行fsck命令检查刚刚建立的文件系统。使用-f选项强制fsck检查新的文件系统。
			# fsck -f /dev/sdb1		##使用fsck检查新建立的文件系统
		测试分区
			现在将新建立的文件系统挂载到相应的目录下，看看是否能够正常工作。
				# mkdir /web	##新建/web目录用于挂载文件系统
				# mount	/dev/sdb1 /web/	##挂载sdb1至/web 目录
				#df /web	##查看该文件系统的使用情况
				文件系统	1K-块		已用	可用	已用号	挂载点
				/dev/sdb1	1929068		35688	1795388		2%	/web
			使用同样的方法在硬盘的第3个分区上建立ext3fs文件系统。
		创建并激活交换分区
			交换分区需要使用mkswap来初始化
				# mkswap /dev/sdb2		##用mkswap初始化第2个分区
				# swapon /dev/sdb2		##用swapon命令检查并激活交换分区
			swapon -s命令查看当前系统上已经存在的交换分区。
				# swapon -s	##列出系统上的交换分区及其使用情况
		配置fstab文件
			最后编辑fstab文件，让系统在启动的时候就加载这些文件系统。在/etc/fstab文件中加入下面这几行命令:
				/dev/sdb1	/web	ext3	defaults	0  	2
				/dev/sdb3	/store	ext3	defaults	0	2
				/dev/sdb2	swap	swap	defaults	0	0
			以/dev/sdb1的配置为例：
				指定将/dev/sdb1安装在目录/web 下;
				文件系统类型是ext3;
				按照默认选项安装;
				按备份频度0执行备份(完整备份) ;
				fsck检查次序为2 (序号为0的最先检查)。
		重新启动系统
			如果某个文件系统出问题，系统不能正常启动，而是引导进入救援模式。
			在这种情况下，用户应该依次按照下面这些步骤来手动解决问题。
				(1)提供root口令，以root身份登录系统。
				(2)使用fsck检查并试图修复受损的文件系统。
				(3)如果问题依然存在，运行mkfs重新在分区上建立文件系统。
				(4)不太幸运的话，可能需要使用fdisk重新建立分区表。
				但无论如何，总是可以通过删除fstab文件中对应的配置行(或者给它打上注释符号),
				来临时解决系统无法正常启动的问题。
	进阶2：高级硬盘管理：RAID和LVM
		对服务器很重要，普通用户很少使用
		独立磁盘冗余阵列：RAID
			RAID用于在多个硬盘上分散存储数据，并且能够“恰当”地重复存储数据，从而保证其中某块硬盘发生故障后不至于影响到整个系统的运转。使用RAID还能够在一定程度上提高读写磁盘的性能。在实际使用中，RAID将几块独立的硬盘组合在一起，形成一个逻辑上的RAID硬盘，这块“硬盘”在外界(如用户、LVM等)看来和真实的硬盘没有任何区别。
			为了使用这项功能，还需要特定的工具来管理RAID。在绝大多数Linux发行版本上，这个工具是mdadm,用户可以需要从安装源下载并安装这个工具。
		逻辑卷管理器：LVM
			逻辑卷管理器LVM可以将几块独立的硬盘组成一个"卷组”。一个“卷组”又可以被分成几个“逻辑卷”。这些逻辑卷在外界看起来就是一个个独立的硬盘分区。这种做法的好处在于，如果管理员某天意识到当初给某个分区划分的空间太小了，那么可以再往卷组里增加一块硬盘，接着把这些富余的空间交给这个逻辑卷，这样就把“分区”扩大了。或者也可以动态地从另一个逻辑卷中“搜刮”一些存储空间，前提是这两个逻辑卷位于同一个卷组中。
			在很多情况下，LVM被设置和RAID一起使用。管理员可以按照下面的顺序建立一个RAID+LVM的管理模式。
				(1)把多块硬盘组合成一个RAID硬盘。
				(2)建立一个LVM卷组。
				(3)将这个RAID硬盘加入LVM卷组。
				(4)在LVM卷组上划分逻辑卷。
	进阶3：备份工作和系统
		备份工具dump和restore
		备份文件系统：dump
			dump命令使用“备份级别”来实现增量备份，每次级别为N的备份会对从上次级别小于N的备份以来，修改过的文件执行备份(下面所有的命令都以root身份执行)。
				# dump -0u -f /dev/nst0 /web 		## 执行从/web到/dev/nst0的0级备份
			选项-0指定dump执行级别为0的备份。备份级别总共有10个(0~9)，级别0表示完整备份,也就是把文件系统上的所有内容全部备份下来，包括那些平时看不到的内容(如分区表)。
			选项-u指定dump更新/etc/dumpdates文件。这个文件中记录了历次备份的时间、备份级别和实施备份的文件系统，dump命令在实施增量备份的时候需要依据这个文件决定哪些文件应该备份。现在，这个文件看起来像下面这个样子。
				# cat/etc/ dumpdates	##查看/etc/dumpdates 文件内容
				/dev/ sdb10 Sun Dec 1418:43:30 2008 +0800
			选项-f指定了用于存放备份的设备，在这里是/dev/nst0，表示磁带设备。最后一个参数是需要备份的文件系统。
			下面在/web下增加一个文件，这个文件的内容是根目录下的文件列表。
				# ls/> /web/ls out
			现在对/web执行一次3级备份。
				# dump -3u -f /dev/nst0 /web	##执行从/web到/dev/nst0的3级备份
			现在查看/etc/dumpdates可以看到多了一条3级备份的记录。
				# cat/etc/dumpdates		##查看/etc/ dumpdates文件内容
				/dev/sdb1 0 Sun Dec 14 18:43:30 2008 +0800
				/dev/sdb1 3 Sun Dec 14 18:46:07 2008 +0800
			一定要使用硬盘做备份的话，只能进行0级(完整)备份。下面这条命令将选择/dev/sdb3作为备份的目标设备(注意此时也就没有必要使用-u选项了)。
				# dump -0 -f /dev/sdb3 /web		##在块设备上执行0级备份
			dump工具有-一个配套的rdump命令，用于将备份转储到远程主机上。为此需要指定远程主机的主机名或者IP地址。
				# rdump -0u -f backup:/dev/nst0 /web
		从灾难中恢复：restore
			使用restore 恢复数据之前，首先需要建立一个临时目录，这个目录用于存放备份设备中的目录层次，用restore恢复的文件也会存放在这个目录下。
				# mkdir /var/restore	##建立用于恢复文件的目录/var/ restore
				# cd /var/ restore/		##进入这个目录
			restore的-i选项用于交互式地恢复单个文件和目录，-f选项用于指定存放备份的设备。下面从dev/sdb3恢复文件ls_out 和login.defs
				# restore -i -f /dev/sdb3
			执行完这条命令后，restore 将用户带至一个交互式的命令行界面。用户可以使用ls和cd命令在备份的文件系统中到处浏览，碰到需要恢复的文件，就用add命令标记它。最后使用extract命令提取所有做过标记的文件和目录。
			文件提取完成后，就可以使用quit 命令退出restore。
				/usr/ local/sbin/restore > quit
			现在查看当前目录(/var/restore) 下的文件列表，可以看到恢复的文件。尽管刚才并没有恢复etc目录，但restore只是为了还原完整的目录结构，事实上现在etc目录下只有一个login.defs 文件。
				#ls -F
				etc/	ls_out
			如果用户不幸把整个文件系统都丢失了，那么可以使用带-r选项的restore命令恢复整个文件系统。
				# cd /web/						##进入需要要恢复的目录
				# restore -r-f /dev/ sdb3		##从/dev/sdb3恢复文件系统
			rrestore命令从远程主机提取备份信息。下面的命令以交互的方式从主机backup恢复由rdump转储的文件系统。
				# rrestore -i -f backup:/dev/nst0
		让备份定时自动完成：cron
			
第9章 用户与用户组管理	
	添加账户John
		$ sudo useradd -m john		## 添加一个用户为john，自动建立主目录
	添加用户
		不带-m参数的useradd命令不会为新用户建立主目录。在这种情况下，用户可以登录到系统的Shell,但不能够登录到图形界面。这是因为桌面环境无论是KDE还是GNOME,需要用到用户主目录中的一些配置文件。
		useradd -g。该参数用于指定用户所属的组。如建立名为mike的用户账号，并指定其属于users组。
			$ sudo useradd -g users mike
		useradd -s参数用于指定用户登录后所使用的Shell。如建立名为mike的用户账号，并指定其登录后使用bash作为Shell。
			$ sudo useradd -s /bin/bash mike
		在系统中添加一个名为newgroup的组。
			$ sudo groupadd newgroup
		使用图形界面完成以上操作：具体操作 略....
		记录用户操作：history
			通过history命令，可看到自己曾经执行的操作。如：$ history
			history记录的命令，被存储在用户主目录的.bash_ history文件中，这个文件默认情况下可以存储1000条命令记录。
				# history 10 ## 列出最近使用的10条命令
			对于管理员来说，可查看此文件，知道每个用户都做了哪里操作。
		/etc/passwd文件用户信息都登记
		/etc/shadow文件则保存着用户的登录密码。
	删除用户：userde1
		$ sudo userde1 mike		## 删除mike账号
		$ sudo userde1 -r john	## 删除mike账号，并删除主目录
	管理用户账号：usermod
		各个选项及含义
		-d		修改用户主目录
		-e		修改账号的有效期限。以公元月/日/年的形式表示( MM/DD/YY )
		-g		修改用户所属的组
		-1		修改用户账号名称
		-S		修改用户登录后所使用的Shell
		
		$ sudo usermod -l mike -d /home/mike -e 12/31/13 john	## 将john改名为mike，主目录改为/home/mike,并设置有效期
	查看用户信息：id
		$ id nobody		##查看nobody用户的UID、GID及所属的组
		$ id 			##查看当前用户的信息
	用户切换：su
		通过su命令所获得的特权将一直持续到使用exit命令退出为止。
		$ su john	## 将当前身份转变为john
		$ exit		## 返回到之前账号
	受限的特权：sudo
		管理员通过配置/etc/sudoers指定用户可以执行的特权命令。
		具体配置方法，略..........
	进阶：配置文件解析
		/etc/passwd文件
		/etc/shadow文件 
		/etc/group文件
		具体文件内容解析，略.......
第10章 进程管理	
	进程的属性
		PID:进程的ID号
		PPID：父进程的PID
		UID和EUID：真实和有效的用户ID
		GID和EGID：真实和有效的组ID 
		谦让度和优先级
	监视进程：ps命令
		$ps aux		## 查看当前系统上运行的所有进程信息
		USER	PID		%CPU	%MEM	VSZ		RSS 	TTY		STAT	START	TIME 	COMMAND
		root	1		0.0		0.0		4020	884		?		Ss		18:41	0:00	/sbin/init
		..........
		
		各字段含义
			USER	进程创建者的用户名
			PID		进程的ID号
			%CPU	进程占用的CPU百分比
			%MEM	进程占用的内存百分比
			VSZ		进程占用的虚拟内存大小
			RSS		内存中页的数量(页是管理内存的单位，在PC.上通常为4K)
			TTY		进程所在终端的ID号
			STAT
				进程状态，常用字母代表的含义如下:
					R正在运行/可运行		D睡眠中(不可被唤醒，通常是在等待I/O设备)
					S睡眠中(可以被唤醒)		T停止(由于收到信号或被跟踪)
					Z僵进程(已经结束而没有释放系统资源的进程)
				常用的附加标志有:
					<进程拥有比普通优先级高的优先级
					N进程拥有比普通优先级低的优先级
					L有些页面被锁在内存中
					s会话的先导进程
			START	进程启动的时间
			TIME	进程已经占用的CPU时间
			COMMAND	命令和参数
		ps的另一组选项lax可以提供父进程ID (PPID) 和谦让度(NI)。ps lax命令不会显示进程属主的用户名，因此可以提供更快的运行速度。
	即时跟踪进程信息：top命令
		$ top
		top命令显示的信息会占满一页，并且在默认情况下每10s 更新一次。那些使用CPU最多的程序会排在最前面。用户还可以即时观察到当前系统CPU使用率、内存占有率等各种信息。最后，使用命令q退出这个监视程序。
	查看占用文件的进程：lsof
		不带任何参数的lsof命令会列出当前系统中所有打开文件的进程信息，要找出占用某个特定文件的进程，需要提供文件名作为参数。
	向进程发送信号：kill
		kill命令只是用来向进程发送一个信号，信号是什么，由用户指定。
		kill -i 显示所有信号及其编号
	调整进程的谦让度：nice和renice
		具体使用，略......
	/PROC文件系统
		/PROC是一个非常特殊的文件系统，或者说它根本不是什么文件系统。/PROC目录下存放着与内核状态有关的各种有意义的信息。在系统运行的时候，内核会随时向这个目录写入数据。ps和top命令就是从这个地方读取数据的。事实上，这是操作系统向用户提供的一条通往内核的通道，用户甚至可以通过向/proc目录下的文件写入数据来修改操作系统参数。	
	
第3篇 网络篇
	第11章	网络配置
	第12章	浏览网页
	第13章	收发邮件
	第14章	传输文件
	第15章	远程登录
	
第11章 网络配置
	一种被称为Ndiswrapper的程序能够利用Windows上的网卡驱动程序配置Linux内核。这样，只要能够获得Windows上的无线网卡驱动。
	进阶1：命令行下配置网络
		使用ifconfig 配置网络接口
			ifconfig命令用于启动或禁用一个网络接口，同时设置其IP地址、子网掩码以及其他网络选项。通常，ifconfig在系统启动时通过接受相关配置文件中的参数完成网络设置。用户也可以随时使用这个命令改变当前网络接口的设置。
			如：将网络接口eth0的IP地址设置为192.168.1.14,子网掩码为255.255.255.0，同时启动这个网络接口。
				$ sudo ifconfig eth0 192.168.1.14 netmask 255.255.255.0 up
			eth0这个名字标识了一个网络硬件接口。其中的eth代表Ethernet,即以太网。第1个以太网接口为eth0， 第2个以太网接口为eth1 ...依次类推。无线网络接口往往以wlan开头，遵循和以太网接口相同的命名法则。
				$ sudo ifconfig  eth0 down 	##关闭网络接口
				$ ifconfig				## 无参数ifconfig显示当前所有网络接口配置
			注：lo的网络接口，表示“环回网络”，这是一没有实际接口的虚拟网络。127.0.0.1这个环回地址始终指向当前主机。
		使用route配置静态路由
			




第12章 浏览网页
	Firefox
	文本浏览器：lynx（用于shell下）
第13章 收发邮件
	Gnome下邮件客户端：Evolution
	KDE下的邮件客户端：Kmail
第14章 传输文件
	
	
第15章 

第4篇 娱乐与办公篇
	第16章 	多媒体
	第17章 	图像
	第18章	打印机配置
	第19章	办公软件的使用

第16章 多媒体
	Gnome下的播放引擎xine、gstreamer
	播放器：Rhythmbox、amarok、MPlayer
第17章 图像
	查看图片KDE下的Konqueror、Gnome下的Nautilus
	GIMPLinux下的Photoshop
	Shotwell管理相册
	LibreOffice的绘画工具
		LibreOffice Draw主要用来设计Logo、流程图和涂鸦
第18章 打印机配置
	略.....
第19章 办公软件的使用
	最常用的办公套件: LibreOffice.org
		这个套件包括了文字处理器(Writer) 、电子表格(Calc) 、演示文稿(Impress) 、公式编辑器(Math)和绘图程序(Draw) 。
	PDF阅读器
		Xpdf运行与X11环境，可用于KDE、Gnome桌面中
		Adobe Reader阅读器，需到Adobe官网下载

第5篇程序开发篇
	第20章	Linux编程
	第21章	She11编程

第20章 Linux编程
	vim使用
	E 使用 
	gedit使用 
第21章 Shell编程
	正则表达式
		$ egrep "^a.*t$" /usr/share/dict/words ## 列出单词表中a开头t结尾的所有单词
		.	用于匹配任意一个字符
		[]	用于指定一个字符集
		-	描述一个范围：[a-z]
		...........
	Shell脚本编程
		
			


第6篇服务器配置篇
	第22章	服务器基础知识
	第23章	HTTP服务器——Apache
	第24章	FTP服务器——vsftpd
	第25章	Samba服务器
	第26章	网络硬盘——NFS
